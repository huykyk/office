package cn.edu.xmu.software.eventprocesser;

import static com.googlecode.javacv.cpp.opencv_core.*; 
import static com.googlecode.javacv.cpp.opencv_highgui.*;  
import static com.googlecode.javacv.cpp.opencv_imgproc.*;  

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.FileDialog;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.media.opengl.GLCapabilities;
import javax.media.opengl.GLProfile;
import javax.media.opengl.awt.GLCanvas;
import javax.swing.JOptionPane;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import com.googlecode.javacv.cpp.opencv_core.CvMat;
import com.googlecode.javacv.cpp.opencv_core.CvScalar;
import cn.edu.xmu.software.curveextraction.Edge;
import cn.edu.xmu.software.curveextraction.CurveExtractOpt;
import cn.edu.xmu.software.ui.DiffusionCurvesUI;
import cn.edu.xmu.software.util.Constants;
import cn.edu.xmu.software.util.ColorControlPoint;

import cn.edu.xmu.software.util.InputTrace;
import cn.edu.xmu.software.util.MatOperate;

import cn.edu.xmu.software.util.Point;
import cn.edu.xmu.software.util.StaticData;
import cn.edu.xmu.software.util.TextureReader;
import cn.edu.xmu.software.util.TextureReader.Texture;
import cn.edu.xmu.software.util.XmlOperate;

/**
 * �ؼ����¼�����
 * @author sinlly.chen
 *
 */
public class ControlsListener implements ActionListener,ChangeListener, ItemListener{
    private static DiffusionCurvesUI frame;
    private Image srcImage;
    private  int rValue;
    private  int gValue;
    private  int bValue;
    private static int index=0;//�Զ�����ɫ�����
    private int selectBtnIndex;//ѡ��Ļ���ɫ�����
    private int selectCustomBtnIndex;//ѡ����Զ�����ɫ�����
	private String fileName;
	private String dir;
	public ControlsListener(DiffusionCurvesUI frame)
    {
    	this.frame=frame;
    }
	@Override
	public void actionPerformed(ActionEvent e) {
		frame.getGLCanvas().setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
		
		if(e.getSource()==frame.getLoadBitmapItem()) //��bitmap�����ļ�
		{
			openFile("bitmap");
			StaticData.gScale=1.0f;
			StaticData.gDx=0;
			StaticData.gDy=0;
		}
		else if(e.getSource()==frame.getLoadXmlItem())//��xml�����ļ�
		{
			openFile("xml");
			StaticData.gScale=1.0f;
			StaticData.gDx=0;
			StaticData.gDy=0;
		}
		else if(e.getSource()==frame.getSaveAsPngItem())//����bitmap��ʽ�ļ�
			saveFile("bitmap");
		else if(e.getSource()==frame.getSaveAsXmlItem())//����xml��ʽ�ļ�
			saveFile("xml");
		else if(e.getSource()==frame.getrTxt())//rTextֵ�ı�
			rValueChange();
		else if(e.getSource()==frame.getgTxt())//gTextֵ�ı�
			gValueChange();
		else if(e.getSource()==frame.getbTxt())//bTextֵ�ı�
			bValueChange();
		else if(e.getSource()==frame.getAddBtn())//����Զ�����ɫ
			addCustomColor();
		else if(chkColorSelect(e))//�����ѡ��Ļ���ɫ
		{
			StaticData.currentSelColor=frame.getColorBtns().get(selectBtnIndex).getBackground();
			StaticData.currentSelColor=new Color(StaticData.currentSelColor.getRed(),StaticData.currentSelColor.getGreen(),StaticData.currentSelColor.getBlue(),0);
			frame.getCustomBtn().setBackground(StaticData.currentSelColor);
			if(StaticData.isSelLColor)
			{
				frame.getlColorShowBtn().setBackground(StaticData.currentSelColor);
				StaticData.leftColor=StaticData.currentSelColor;
			}
			else if(StaticData.isSelRColor)
			{
				frame.getrColorShowBtn().setBackground(StaticData.currentSelColor);
				StaticData.rightColor=StaticData.currentSelColor;
			}
			else{//�Ա�ѡ����ɫ���Ƶ������ɫ�༭
			    MethodTool.pushState();
				for(int i=0;i<StaticData.allCurves.size();i++){
					if(StaticData.allCurves.get(i).isSelected()){
						ArrayList<ColorControlPoint> cPoints=StaticData.allCurves.get(i).getColorControlPoints();
						for(int j=0;j<cPoints.size();j++){
							if(cPoints.get(j).isLeftPointSelected())
								cPoints.get(j).setLeftColor(StaticData.currentSelColor);
							if(cPoints.get(j).isRightPointSelected())
								cPoints.get(j).setRightColor(StaticData.currentSelColor);
						}
					}
				}
				frame.getGLCanvas().display();
			}
		}
		else if(chkCustomColorSelect(e))//�����ѡ����Զ�����ɫ
		{
			StaticData.currentSelColor=frame.getCustomColorBtns().get(selectCustomBtnIndex).getBackground();
			StaticData.currentSelColor=new Color(StaticData.currentSelColor.getRed(),StaticData.currentSelColor.getGreen(),StaticData.currentSelColor.getBlue(),0);
			frame.getCustomBtn().setBackground(StaticData.currentSelColor);
			if(StaticData.isSelLColor)
			{
				frame.getlColorShowBtn().setBackground(StaticData.currentSelColor);
				StaticData.leftColor=StaticData.currentSelColor;
			}
			if(StaticData.isSelRColor)
			{
				frame.getrColorShowBtn().setBackground(StaticData.currentSelColor);
				StaticData.rightColor=StaticData.currentSelColor;
			}
			else{//�Ա�ѡ����ɫ���Ƶ������ɫ�༭
			    MethodTool.pushState();
				for(int i=0;i<StaticData.allCurves.size();i++){
					if(StaticData.allCurves.get(i).isSelected()){
						ArrayList<ColorControlPoint> cPoints=StaticData.allCurves.get(i).getColorControlPoints();
						for(int j=0;j<cPoints.size();j++){
							if(cPoints.get(j).isLeftPointSelected())
								cPoints.get(j).setLeftColor(StaticData.currentSelColor);
							if(cPoints.get(j).isRightPointSelected())
								cPoints.get(j).setRightColor(StaticData.currentSelColor);
						}
					}
				}
				frame.getGLCanvas().display();
			}
		}
		else if(e.getSource()==frame.getDrawBtn()){//��ͼ����
			StaticData.isAddLines=true;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isLoadPng=false;
			StaticData.isCleanAll=false;
			StaticData.isDraw=true;
			StaticData.isLoadXml=false;
			StaticData.isStForAdjusting=false;
			StaticData.isStForMdColor=false;
			if(StaticData.isCurveLineOnly)
			{
				StaticData.isColorCurveLine=false;
			}
			else if(StaticData.isColorCurveLine)
			{
				StaticData.isCurveLineOnly=false;
			}
			else if(StaticData.isDiffuseLine)
			{
				
			}
			else 
			{
				StaticData.isDiffuseLine=false;
				StaticData.isColorCurveLine=false;
				StaticData.isCurveLineOnly=false;
				StaticData.isSample=false;
			}
			if(StaticData.isPictureRepair)
				StaticData.isPictureSample=true;
			else
				StaticData.isPictureSample=false;
		}
		else if(e.getSource()==frame.getZoomInBtn()){//�Ŵ����
			StaticData.isAddLines=false;
			StaticData.isZoomIn=true;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			zoom(1);
		}
		else if(e.getSource()==frame.getZoomOutBtn()){//��С����
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=true;
			StaticData.isHandPan=false;
			zoom(-1);
		}
		else if(e.getSource()==frame.getHandPanBtn()){//ƽ�Ʋ���
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=true;
			StaticData.isLoadPng=false;
			StaticData.isPictureRepair=false;
			frame.getGLCanvas().setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
		}
		else if(e.getSource()==frame.getMagnetBtn())//��ȡͼ������
		{
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isCleanAll=false;
			StaticData.isDraw=true;
			StaticData.isDiffusing=true;
			StaticData.isLoadXml=false;
			StaticData.isStForAdjusting=false;
			StaticData.isStForMdColor=false;
			StaticData.isCurveLineOnly=true;
			StaticData.isColorCurveLine=false;
			StaticData.isDiffuseLine=false;
			StaticData.isPictureSample=true;
			StaticData.isPictureRepair=false;
			if(!StaticData.isSample)
			       sample();

		    frame.getGLCanvas().display();
		}
		else if(e.getSource()==frame.getSampleBtn())//��ȡ��ɫ����û�г�ȡͼ���������ȡͼ��������
		{
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isCleanAll=false;
			StaticData.isDraw=true;
			StaticData.isDiffusing=true;
			StaticData.isStForAdjusting=false;
			StaticData.isStForMdColor=false;
			StaticData.isCurveLineOnly=false;
			StaticData.isColorCurveLine=true;
			StaticData.isLoadXml=false;
			StaticData.isDiffuseLine=false;
			StaticData.isPictureRepair=false;
			StaticData.isPictureSample=true;//����Ƿ�Ҫ���л��ߵ�ʱ����ɫ����
			if(!StaticData.isSample)
				sample();
			frame.getGLCanvas().display();
		}
		else if(e.getSource()==frame.getDiffuseBtn())//��ɢ����û�г�ȡ��������ȡ��ɫ����ִ�����ǣ�
		{
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isCleanAll=false;
			StaticData.isDraw=true;
			StaticData.isDiffusing=true;
			StaticData.isStForAdjusting=false;
			StaticData.isStForMdColor=false;
			StaticData.isCurveLineOnly=false;
			StaticData.isColorCurveLine=false;
			StaticData.isDiffuseLine=true;
			StaticData.isLoadXml=false;
			StaticData.isPictureSample=true;
			StaticData.isPictureRepair=false;
			if(!StaticData.isSample)
				sample();
			frame.getGLCanvas().display();
		}
		else if(e.getSource()==frame.getRepairColorBtn())//�޲���ɫ����ʱ��Ҫ�����Ա�ͼ��Ļ���
		{
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isCleanAll=false;
			StaticData.isDraw=true;
			StaticData.isDiffusing=true;
			StaticData.isStForAdjusting=false;
			StaticData.isStForMdColor=false;
			StaticData.isPictureSample=true;
			StaticData.isPictureRepair=true;
			if(!StaticData.isOpenPicturePanel)
			{
				this.openPicturePanel();
				StaticData.isOpenPicturePanel=true;
			}
		}
		else if(e.getSource()==frame.getCartoonChk()&&frame.getCartoonChk().isSelected())//ѡ���ǿ�ͨͼƬ
		{
			StaticData.isCartoon=true;
		}
		else if(e.getSource()==frame.getCartoonChk()&&!frame.getCartoonChk().isSelected())//���ǿ�ͨͼƬ
		{
			StaticData.isCartoon=false;
		}
		else if(e.getSource()==frame.getCleanAllBtn())//���ǰ���������������
		{
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isDraw=false;
			StaticData.isPictureRepair=false;
			StaticData.isLoadPng=false;
			StaticData.isCleanAll=true;
			StaticData.isStForAdjusting=false;
			StaticData.isStForMdColor=false;
			StaticData.isSample=false;
			StaticData.isCurveLineOnly=false;
			StaticData.isColorCurveLine=false;
			StaticData.isLoadXml=false;
			StaticData.isPictureSample=false;
			StaticData.gScale=1.0f;
			StaticData.gDx=0;
			StaticData.gDy=0;
			frame.getGLCanvas().display();
			if(frame.getImgGlCanvas()!=null)
				frame.getImgGlCanvas().display();
		}
		else if(e.getSource()==frame.getlColorBtn())//������ʱ������ɫ
		{
			StaticData.isSelLColor=true;
			StaticData.isSelRColor=false;
		}
		else if(e.getSource()==frame.getrColorBtn())//������ʱ������ɫ
		{
			StaticData.isSelRColor=true;
			StaticData.isSelLColor=false;
		}
		else if(e.getSource()==frame.getSmoothBtn())//��������ƽ���ӽ�ֱ��
		{
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isCleanAll=false;
			StaticData.isStForAdjusting=false;
			StaticData.isStForMdColor=false;
			StaticData.isSample=false;
			StaticData.isCurveLineOnly=false;
			StaticData.isColorCurveLine=false;
			StaticData.isLoadXml=false;
			StaticData.isPictureSample=false;
			StaticData.isPictureRepair=false;

		}

		else if(e.getSource()==frame.getRedoBtn())//��ǰ����
		{
		      redo();
		}
		else if(e.getSource()==frame.getUndoBtn())//�����
		{
		     undo();	
		}

		else if(e.getSource()==frame.getAdjustBtn()){//����������״��λ��
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isDraw=true;
			StaticData.isSelRColor=false;
			StaticData.isSelLColor=false;
			StaticData.isCleanAll=false;
			StaticData.isStForAdjusting=true;
			StaticData.isPictureSample=false;
			StaticData.isStForMdColor=false;
			StaticData.isPictureRepair=false;
			StaticData.isLoadXml=false;
			frame.getGLCanvas().requestFocusInWindow();
			frame.getGLCanvas().display();
		}
		else if(e.getSource()==frame.getModifyColorBtn()){//��������������ɫ
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isDraw=true;
			StaticData.isSelRColor=false;
			StaticData.isSelLColor=false;
			StaticData.isStForAdjusting=false;
			StaticData.isStForMdColor=true;
			StaticData.isPictureSample=false;
			StaticData.isLoadXml=false;
			StaticData.isPictureRepair=false;
			frame.getGLCanvas().requestFocusInWindow();
			frame.getGLCanvas().display();
		}
		else if(e.getSource()==frame.getExchangeBtn()){//������ѡ�����ߵ�������ɫ
			boolean isExchanged=false;
			 MethodTool.pushState();
			for(int i=0;i<StaticData.allCurves.size();i++){
				if(StaticData.allCurves.get(i).isSelected()){
					isExchanged=true;
					for(int j=0;j<StaticData.allCurves.get(i).getColorControlPoints().size();j++){
						Color rightColor=StaticData.allCurves.get(i).getColorControlPoints().get(j).getRightColor();
						Color tempColor=StaticData.allCurves.get(i).getColorControlPoints().get(j).getLeftColor();
						StaticData.allCurves.get(i).getColorControlPoints().get(j).setLeftColor(rightColor);
						StaticData.allCurves.get(i).getColorControlPoints().get(j).setRightColor(tempColor);
					}
				}
			}
			if(!isExchanged){
				JOptionPane.showMessageDialog(frame, "Please select a curve first!", "Select A Curve First", JOptionPane.INFORMATION_MESSAGE);
			}
			frame.getGLCanvas().display();
			frame.getGLCanvas().requestFocusInWindow();
		}
		else if(e.getSource()==frame.getDeleteCurveBtn())//ɾ������
		{
			deleteCurves();
		}
		else if(e.getSource()==frame.getContrastIncrBtn())//��������������ɫ�Աȶ�
		{
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isDraw=true;
			StaticData.isSelRColor=false;
			StaticData.isSelLColor=false;
			StaticData.isCleanAll=false;
			StaticData.isLoadXml=false;
			StaticData.isPictureSample=false;
			StaticData.isPictureRepair=false;
			contrastIncrese(true);
		}
		else if(e.getSource()==frame.getContrastDecrBtn())//��С����������ɫ�Աȶ�
		{
			StaticData.isAddLines=false;
			StaticData.isZoomIn=false;
			StaticData.isZoomOut=false;
			StaticData.isHandPan=false;
			StaticData.isDraw=true;
			StaticData.isSelRColor=false;
			StaticData.isSelLColor=false;
			StaticData.isCleanAll=false;
			StaticData.isPictureSample=false;
			StaticData.isPictureRepair=false;
			StaticData.isLoadXml=false;
			contrastIncrese(false);		
		}
		else if(e.getSource()==frame.getSwitchImagePanelBtn())//�л��޲���ɫʱ��ԭͼ�Ļ�������
		{
			if(StaticData.isOpenPicturePanel)
			{
				this.closePicturePanel();
				StaticData.isOpenPicturePanel=false;
			}
			else if(!StaticData.isOpenPicturePanel)
			{
				this.openPicturePanel();
				StaticData.isOpenPicturePanel=true;
			}
		}
		else if(e.getSource()==frame.getAddColorPntItem())//�һ������ɫ���Ƶ�
		{
			int i=0;
			InputTrace selectedCurve=StaticData.allCurves.get(StaticData.curSelectedIndex);
			//ѭ���ҵ����Ƶ�Ĳ���λ��
			for(i=0;i<selectedCurve.getColorControlPoints().size();i++){
				if(StaticData.curAddColorPnt.getIndex()<selectedCurve.getColorControlPoints().get(i).getIndex()){
					break;
				}
			}
			Color leftColor=null;
			Color rightColor=null;
			//���������Ƶ������ɫ
			if(StaticData.isCurveLineOnly || StaticData.isDiffuseLine || StaticData.isColorCurveLine){
				
				int before=StaticData.curAddColorPnt.getIndex()-1;
				int after=StaticData.curAddColorPnt.getIndex()+1;
				Point before_point=selectedCurve.getInputTrace().get(before);
				Point after_point=selectedCurve.getInputTrace().get(after);
				
				Point add_left=new Point();
				Point add_right=new Point();
				
				Point[] tempPoint=getColorPoint(before_point,after_point);
				add_left=tempPoint[0];
				add_right=tempPoint[1];
				CvScalar addleftcolor;
				CvScalar addrightcolor;
				addleftcolor=cvGet2D(StaticData.rgbaImage,add_left.getY(),add_left.getX());
				addrightcolor=cvGet2D(StaticData.rgbaImage,add_right.getY(),add_right.getX());
				leftColor=new Color((int)addleftcolor.getVal(2), 
						(int)addleftcolor.getVal(1), 
						(int)addleftcolor.getVal(0), 
						0);
				rightColor=new Color((int)addrightcolor.getVal(2), 
						(int)addrightcolor.getVal(1), 
						(int)addrightcolor.getVal(0), 
						0);
			}
			else{
				int dis=selectedCurve.getColorControlPoints().get(i).getIndex()-selectedCurve.getColorControlPoints().get(i-1).getIndex();
				int beginR=selectedCurve.getColorControlPoints().get(i-1).getLeftColor().getRed();
				int beginG=selectedCurve.getColorControlPoints().get(i-1).getLeftColor().getGreen();
				int beginB=selectedCurve.getColorControlPoints().get(i-1).getLeftColor().getBlue();
				int beginA=selectedCurve.getColorControlPoints().get(i-1).getLeftColor().getAlpha();
				int rDis=selectedCurve.getColorControlPoints().get(i).getLeftColor().getRed()-beginR;
				int gDis=selectedCurve.getColorControlPoints().get(i).getLeftColor().getGreen()-beginG;
				int bDis=selectedCurve.getColorControlPoints().get(i).getLeftColor().getBlue()-beginB;
				int aDis=selectedCurve.getColorControlPoints().get(i).getLeftColor().getAlpha()-beginA;
				int index=StaticData.curAddColorPnt.getIndex()-selectedCurve.getColorControlPoints().get(i-1).getIndex();
				int newR=(int)(beginR+index*((float)rDis)/dis);
				int newG=(int)(beginG+index*((float)gDis)/dis);
				int newB=(int)(beginB+index*((float)bDis)/dis);
				int newA=(int)(beginA+index*((float)aDis)/dis);
				leftColor=new Color(newR, newG, newB, newA);
				//���������Ƶ������ɫ
				beginR=selectedCurve.getColorControlPoints().get(i-1).getRightColor().getRed();
				beginG=selectedCurve.getColorControlPoints().get(i-1).getRightColor().getGreen();
				beginB=selectedCurve.getColorControlPoints().get(i-1).getRightColor().getBlue();
				beginA=selectedCurve.getColorControlPoints().get(i-1).getRightColor().getAlpha();
				rDis=selectedCurve.getColorControlPoints().get(i).getRightColor().getRed()-beginR;
				gDis=selectedCurve.getColorControlPoints().get(i).getRightColor().getGreen()-beginG;
				bDis=selectedCurve.getColorControlPoints().get(i).getRightColor().getBlue()-beginB;
				aDis=selectedCurve.getColorControlPoints().get(i).getRightColor().getAlpha()-beginA;
				newR=(int)(beginR+index*((float)rDis)/dis);
				newG=(int)(beginG+index*((float)gDis)/dis);
				newB=(int)(beginB+index*((float)bDis)/dis);
				newA=(int)(beginA+index*((float)aDis)/dis);
				
				rightColor=new Color(newR, newG, newB, newA);
			}
			//���������Ƶ�ķ���ƫ�Ƶó�������ɫ��
			double[] V=new double[2];
			double[] N=new double[2];
			double[] PM;
			double[] N1=new double[2];
			double[] N2=new double[2];
			double vx=0,vy=0;
			int selectedIndex=StaticData.curAddColorPnt.getIndex();
			V[0]=selectedCurve.getInputTrace().get(selectedIndex).getX()-selectedCurve.getInputTrace().get(selectedIndex-1).getX();
			V[1]=selectedCurve.getInputTrace().get(selectedIndex).getY()-selectedCurve.getInputTrace().get(selectedIndex-1).getY();
			N1=MethodTool.getNormal(V);
			vx+=V[0];
			vy+=V[1];
			V[0]=selectedCurve.getInputTrace().get(selectedIndex+1).getX()-selectedCurve.getInputTrace().get(selectedIndex).getX();
			V[1]=selectedCurve.getInputTrace().get(selectedIndex+1).getY()-selectedCurve.getInputTrace().get(selectedIndex).getY();
			N2=MethodTool.getNormal(V);
			vx+=V[0];
			vy+=V[1];
			N[0]=(N1[0]+N2[0])/2.0;
			N[1]=(N1[1]+N2[1])/2.0;

			double[] vxy=new double[2];
			vxy[0]=vx;
			vxy[1]=vy;
			PM=MethodTool.getPMValue(vxy);
			
			double leftXX=selectedCurve.getInputTrace().get(selectedIndex).getX()-N[0]*PM[0]*10+0.5;
			double leftYY=selectedCurve.getInputTrace().get(selectedIndex).getY()-N[1]*PM[1]*10+0.5;
			double rightXX=selectedCurve.getInputTrace().get(selectedIndex).getX()+N[0]*PM[0]*10+0.5;
			double rightYY=selectedCurve.getInputTrace().get(selectedIndex).getY()+N[1]*PM[1]*10+0.5;
			
			ColorControlPoint colorCtrPoint=new ColorControlPoint();
			colorCtrPoint.setIndex(StaticData.curAddColorPnt.getIndex());
			colorCtrPoint.setX(StaticData.curAddColorPnt.getX());
			colorCtrPoint.setY(StaticData.curAddColorPnt.getY());
			colorCtrPoint.setLeftColor(leftColor);
			colorCtrPoint.setLeftColorPoint(new Point((int)leftXX, (int)leftYY));
			colorCtrPoint.setRightColor(rightColor);
			colorCtrPoint.setRightColorPoint(new Point((int)rightXX, (int)rightYY));
			
			selectedCurve.getColorControlPoints().add(i, colorCtrPoint);
			
			frame.getGLCanvas().display();
		}
		else if(e.getSource()==frame.getAddShapePntItem())//�һ������״���Ƶ�
		{
			
		}
		else if(e.getSource()==frame.getRemoveColorPntItem())//ɾ����ɫ���Ƶ�
		{
			InputTrace selectedCurve=StaticData.allCurves.get(StaticData.curSelectedIndex);
			int size=selectedCurve.getColorControlPoints().size();
			if(size==2){
				JOptionPane.showMessageDialog(frame, "Can not delete the first and last color control point!", "Delete Error!", JOptionPane.ERROR_MESSAGE);
				return;
			}
			int dis=10000;
			int deleteIndex=-1;
			for(int i=1;i<selectedCurve.getColorControlPoints().size()-1;i++)
				if(MethodTool.getDis(StaticData.curAddColorPnt, selectedCurve.getColorControlPoints().get(i))<dis){
					deleteIndex=i;
					dis=MethodTool.getDis(StaticData.curAddColorPnt, selectedCurve.getColorControlPoints().get(i));
				}
			if(deleteIndex!=-1)
				selectedCurve.getColorControlPoints().remove(deleteIndex);
		}
		else if(e.getSource()==frame.getRemoveShapePntItem())//ɾ����״���Ƶ�
		{
			
		}
	}
	@Override
	public void stateChanged(ChangeEvent e) {
		// TODO Auto-generated method stub
		if(e.getSource()==frame.getrSlider())//�ı�r������
		{
			frame.getrTxt().setText(String.valueOf(frame.getrSlider().getValue()));
			getRGBColorValue();
			frame.getRgbColorBtn().setBackground(new Color(rValue,gValue,bValue));
		}
		else if(e.getSource()==frame.getgSlider())//�ı�g������
	    {
			frame.getgTxt().setText(String.valueOf(frame.getgSlider().getValue()));
			getRGBColorValue();
			frame.getRgbColorBtn().setBackground(new Color(rValue,gValue,bValue));
		}
		else if(e.getSource()==frame.getbSlider())//�ı�b������
		{
			frame.getbTxt().setText(String.valueOf(frame.getbSlider().getValue()));
			getRGBColorValue();
			frame.getRgbColorBtn().setBackground(new Color(rValue,gValue,bValue));
		}
		else if(e.getSource()==frame.getBlurSlider())//�ı�ѡ��blur���Ƶ��blurֵ(Aͨ����ֵ)
		{
			MethodTool.pushState();
			float alphaValue=(float)(frame.getBlurSlider().getValue())/10.0f;
			alphaValue*=255;
			for(int i=0;i<StaticData.allCurves.size();i++){
				if(StaticData.allCurves.get(i).isSelected()){
					ArrayList<ColorControlPoint> cPoints=StaticData.allCurves.get(i).getColorControlPoints();
					for(int j=0;j<cPoints.size();j++){
						if(cPoints.get(j).isCenterPointSelected()){
							cPoints.get(j).setLeftColor(new Color(cPoints.get(j).getLeftColor().getRed(),
									cPoints.get(j).getLeftColor().getGreen(),cPoints.get(j).getLeftColor().getBlue(),(int)alphaValue));
							cPoints.get(j).setRightColor(new Color(cPoints.get(j).getRightColor().getRed(),cPoints.get(j).getRightColor().getGreen(),
									cPoints.get(j).getRightColor().getBlue(),(int)alphaValue));
						}	
					}
				}
			}
			frame.getGLCanvas().display();
		}
	}
	
	@Override
	public void itemStateChanged(ItemEvent e) {
		if (e.getSource() == frame.getSplineChk()) {
			if (frame.getSplineChk().isSelected()) {
				StaticData.isShowSplines = true;
				frame.getGLCanvas().display();
			} else {
				StaticData.isShowSplines = false;
				frame.getGLCanvas().display();
			}
		} else if (e.getSource() == frame.getActiveBlurChk()) {
			if (frame.getActiveBlurChk().isSelected()) {
				StaticData.isActiveBlur = true;
				if(frame.getBlurPanel().getBackground().equals(Constants.maskColor))
					frame.getBlurPanel().setBackground(null);
				frame.getGLCanvas().display();
			} else {
				if(frame.getBlurPanel().getBackground().equals(Constants.maskColor))
					frame.getBlurPanel().setBackground(null);
				StaticData.isActiveBlur = false;
				MethodTool.pushState();
				frame.getGLCanvas().display();
			}
		}
	}
	
	/**
	 * ���ļ�
	 * @param fileType
	 */
	public void openFile(String fileType)
	{
		FileDialog openDialog=new FileDialog(frame,"���ļ�",FileDialog.LOAD);
		openDialog.show(); 
		if(fileType.equals("bitmap"))
		{
		    fileName=openDialog.getFile();
		    dir=openDialog.getDirectory();
		    if(fileName==null||fileName.contains("xml"))
		    {
		    	JOptionPane.showMessageDialog(frame, "Open File Type Error", "Failure", JOptionPane.ERROR_MESSAGE);
		    }
		    else
		    {
		    	try {
					Texture image = TextureReader.readTexture(dir+fileName, true);
					StaticData.grayImage=cvLoadImageM(dir+fileName,CV_LOAD_IMAGE_GRAYSCALE);
					StaticData.isAddLines=false;
					StaticData.isZoomIn=false;
					StaticData.isZoomOut=false;
					StaticData.isHandPan=false;
					StaticData.isLoadPng=true;
					StaticData.isSample=false;
					StaticData.isCurveLineOnly=false;
					StaticData.isColorCurveLine=false;
					StaticData.isPictureSample=false;
		    		StaticData.isLoadXml=false;
					StaticData.imgHeight=image.getHeight();
					StaticData.imgWidth=image.getWidth();
					StaticData.imgBuf=image.getPixels();
					frame.getGLCanvas().display();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
		    }
			if(frame.getImgGlCanvas()!=null)
				frame.getImgGlCanvas().display();
		}
		else if(fileType.equals("xml"))
		{ 
			fileName=openDialog.getFile();
		    dir=openDialog.getDirectory();
		    if(fileName==null||!fileName.contains("xml"))
		    {
		    	JOptionPane.showMessageDialog(frame, "Open File Type Error", "Failure", JOptionPane.ERROR_MESSAGE);
		    }
		    else
		    {
		    	
		    		XmlOperate xmlOperater = new XmlOperate();
		    		xmlOperater.ReadXML(dir+fileName);
		    		StaticData.allCurves=(ArrayList<InputTrace>) xmlOperater.getCurves();
		    		if(xmlOperater!=null)
		    		{
		    			StaticData.repairCurves=(ArrayList<InputTrace>)xmlOperater.getRepairCurves();
		    		}
		    		StaticData.isZoomIn=false;
		    		StaticData.isZoomOut=false;
		    		StaticData.isHandPan=false;
		    		StaticData.isLoadPng=false;
		    		StaticData.isSample=false;
		    		StaticData.isCurveLineOnly=false;
		    		StaticData.isColorCurveLine=false;
		    		StaticData.isPictureSample=false;
		    		StaticData.isAddLines=false;
		    		StaticData.isDraw=true;
		    		StaticData.isDiffusing=true;
		    		StaticData.isLoadXml=true;
					frame.getGLCanvas().display();
				
		    }
		}
		openDialog.dispose();
	}
	/**
	 * �����ļ�
	 * @param fileType
	 */
    public void saveFile(String fileType)
    {
    	FileDialog saveDialog=new FileDialog(frame,"�����ļ�",FileDialog.SAVE);
		String fileName;
		String dir;
		saveDialog.show();
	    fileName=saveDialog.getFile();
	    dir=saveDialog.getDirectory();
		if(fileType.equals("bitmap"))
		{
		    if(fileName!=null)
		    {
                if(getCurrentImageMat())
                {
                	cvSaveImage(dir+fileName, StaticData.rgbaImage);
                	JOptionPane.showMessageDialog(frame, "Image save success", "Success", JOptionPane.INFORMATION_MESSAGE);
                }
                else 
                	JOptionPane.showMessageDialog(frame, "Image save fail", "Failure", JOptionPane.ERROR_MESSAGE);
             }
		}
		else if(fileType.equals("xml"))
		{
			System.out.println("savexml");
			if(fileName!=null)
		    {
				if(StaticData.allCurves != null && StaticData.repairCurves.size()==0)
				{
					XmlOperate xmlOperater = new XmlOperate();
					xmlOperater.writeToXml(StaticData.allCurves,dir+fileName);
					JOptionPane.showMessageDialog(frame, "Xml save success", "Success", JOptionPane.INFORMATION_MESSAGE);
				}
				else if(StaticData.allCurves != null&& StaticData.repairCurves.size()!=0){
					XmlOperate xmlOperater = new XmlOperate();
					xmlOperater.writeToXmlr(StaticData.allCurves,StaticData.repairCurves,dir+fileName);
				}
				else 
                	JOptionPane.showMessageDialog(frame, "xml save fail", "Failure", JOptionPane.ERROR_MESSAGE);
		    }
		}
		saveDialog.dispose();
    }

 /**
  * ��õ�ǰͼ��ľ���
  * @param fileName
  * @return
  */
public static boolean  getCurrentImageMat()  
{  
	frame.getGLCanvas().display();
	byte[] data=StaticData.screenBuf.array();
	int k=0;
    for(int i=(int)Constants.drawWidth-1;i>=0;i--)
    {
    	for(int j=0;j<(int)Constants.drawWidth;j++)
    	{
    		CvScalar color=new CvScalar(data[k+2]*2+1,data[k+1]*2+1,data[k]*2+1,data[k+3]*2+1);
    		cvSet2D(StaticData.rgbaImage,i,j,color);
    		k+=4;
    	}
    }
    return true;
}  
	/**
	 * �ı�rValue��ֵ��������ɫbutton�ı���ɫ�Լ�Sliderֵ�ı�
	 */
	public void rValueChange()
	{
		rValue=0;
		gValue=Integer.valueOf(frame.getgTxt().getText());
		bValue=Integer.valueOf(frame.getbTxt().getText());
		if(frame.getrTxt().getText().equals("")||frame.getrTxt().getText()==null)
			rValue=0;
		else if(Integer.valueOf(frame.getrTxt().getText())>255)
			rValue=255;
		else 
			rValue=Integer.valueOf(frame.getrTxt().getText());
		frame.getrSlider().setValue(rValue);
		frame.getRgbColorBtn().setBackground(new Color(rValue,gValue,bValue));
	}
	/**
	 * �ı�gValue��ֵ��������ɫbutton�ı���ɫ�Լ�Sliderֵ�ı�
	 */
	public void gValueChange()
	{
		rValue=Integer.valueOf(frame.getgTxt().getText());
		gValue=0;
		bValue=Integer.valueOf(frame.getbTxt().getText());
		if(frame.getgTxt().getText().equals("")||frame.getgTxt().getText()==null)
			gValue=0;
		else if(Integer.valueOf(frame.getrTxt().getText())>255)
			gValue=255;
		else 
			gValue=Integer.valueOf(frame.getgTxt().getText());
		frame.getgSlider().setValue(gValue);
		frame.getRgbColorBtn().setBackground(new Color(rValue,gValue,bValue));
	}
	/**
	 * �ı�bValue��ֵ��������ɫbutton�ı���ɫ�Լ�Sliderֵ�ı�
	 */
	public void bValueChange()
	{
		rValue=Integer.valueOf(frame.getrTxt().getText());
		gValue=Integer.valueOf(frame.getgTxt().getText());
		bValue=0;
		if(frame.getbTxt().getText().equals("")||frame.getbTxt().getText()==null)
			bValue=0;
		else if(Integer.valueOf(frame.getbTxt().getText())>255)
			bValue=255;
		else 
			bValue=Integer.valueOf(frame.getbTxt().getText());
		frame.getbSlider().setValue(bValue);
		frame.getRgbColorBtn().setBackground(new Color(rValue,gValue,bValue));
	}
	/**
	 * ������µ�������ɫֵ
	 */
	public void getRGBColorValue()
	{
		rValue=Integer.valueOf(frame.getrTxt().getText());
		gValue=Integer.valueOf(frame.getgTxt().getText());
		bValue=Integer.valueOf(frame.getbTxt().getText());
	}
	/**
	 * ����Զ�����ɫ
	 */
	public void addCustomColor()
	{
		getRGBColorValue();
		Color c=new Color(rValue,gValue,bValue);
		frame.getCustomColorBtns().get(index).setBackground(c);
		index++;
		if(index>=36)
			index=0;
	}
	/**
	 * �ж��Ƿ�ѡ�����ɫ
	 * @param e
	 * @return
	 */
	public boolean chkColorSelect(ActionEvent e)
	{
		for(int i=0;i<frame.getColorBtns().size();i++)
		{
			if(e.getSource()==frame.getColorBtns().get(i))
			{
				selectBtnIndex=i;
				return true;
			}
		}
		return false;
	}
	/**
	 * �ж��Ƿ�ѡ���Զ�����ɫ
	 * @param e
	 * @return
	 */
	public boolean chkCustomColorSelect(ActionEvent e)
	{
		for(int i=0;i<frame.getCustomColorBtns().size();i++)
		{
			if(e.getSource()==frame.getCustomColorBtns().get(i))
			{
				selectCustomBtnIndex=i;
				return true;
			}
		}
		return false;
	}
	/**
	 * ��ȡͼƬ��������
	 */
	public void sample()
	{
		getCurrentImageMat();
		StaticData.allCurves.clear();
		MethodTool.pushState();
//		if(!StaticData.isLoadPng)
//		{
			cvCvtColor(StaticData.rgbaImage,StaticData.grayImage1,CV_RGB2GRAY);
			cvConvert(StaticData.grayImage1,StaticData.grayImage);
//		}
	    CurveExtractOpt opt=new CurveExtractOpt();
	    if(StaticData.isCartoon)
	        opt.CurveOperate(StaticData.grayImage, true);
	    else 
	    	opt.CurveOperate(StaticData.grayImage, false);
	    StaticData.edges=opt.getEdges();
	    for(int i=0;i<StaticData.edges.size();i++)
	    {
	    	Edge e=StaticData.edges.get(i);
	    	StaticData.currentInput=new ArrayList<Point>(e.getPnts());
	    	MouseProcesser.addLine(e.getStartLColor(),e.getStartRColor(),e.getEndLColor(),e.getEndRColor());
	    }
	    StaticData.isLoadPng=false;
	    StaticData.isSample=true;
	}
	/**
	 * @return the srcImage
	 */
	public Image getSrcImage() {
		return srcImage;
	}
	/**
	 * @param srcImage the srcImage to set
	 */
	public void setSrcImage(Image srcImage) {
		this.srcImage = srcImage;
	}
	
	/*
	 * @param zoom in if num=1, zoom out if num=-1
	 */
	public void zoom(int num){
		float lastgScale=StaticData.gScale;
		StaticData.gScale+=num*0.1f;
		if(StaticData.gScale<0.1)
			StaticData.gScale=0.1f;
		else if(StaticData.gScale>3)
			StaticData.gScale=3;
		int vpx=-(int)(Constants.drawWidth*(StaticData.gScale-lastgScale))/2;
		int vpy=vpx;
		StaticData.gDx+=vpx;
		StaticData.gDy+=vpy;
		frame.getGLCanvas().display();
	}
	/**
	 * �Աȶȵ���
	 * @param ifIncrese  �Ƿ�������Աȶȣ�true��ʾ����Աȶȣ�false��ʾ��С�Աȶ�
	 */
	private void contrastIncrese(boolean ifIncrese)
	{
		MethodTool.pushState();
		for(int i=0;i<StaticData.allCurves.size();i++){
			if(StaticData.allCurves.get(i).isSelected()){
//				  for(int i=0;i<StaticData.allCurves.get(i).getColorControlPoints().size();i++)
				  ArrayList<ColorControlPoint> colorControlPnts=new ArrayList<ColorControlPoint>(StaticData.allCurves.get(i).getColorControlPoints());
				  for(int k=0;k<colorControlPnts.size();k++)
				  {
					  Color lColor=colorControlPnts.get(k).getLeftColor();
					  float[] lhsv=new float[3];
					  Color.RGBtoHSB(lColor.getRed(), lColor.getGreen(), lColor.getBlue(), lhsv);
					  Color rColor=colorControlPnts.get(k).getRightColor();
					  float[] rhsv=new float[3];
					  Color.RGBtoHSB(rColor.getRed(), rColor.getGreen(), rColor.getBlue(), rhsv);
					  if(lhsv[2]>=rhsv[2])
					  {
						  lColor=ifIncrese? lColor.brighter():lColor.darker();
						  rColor=ifIncrese? rColor.darker():rColor.brighter();
					  }
					  else 
					  {
						  lColor=ifIncrese? lColor.darker():lColor.brighter();
						  rColor=ifIncrese? rColor.brighter():rColor.darker();
					  }
					  colorControlPnts.get(k).setLeftColor(lColor);
					  colorControlPnts.get(k).setRightColor(rColor);
				  }
				 
				 StaticData.allCurves.get(i).setColorControlPoints(colorControlPnts);
				}
			}
		frame.getGLCanvas().display();
	}
	
	/**
	 * ��UI��������ʾ�޲���ɫʱ���յ�ԭͼƬ�Ļ���
	 */
	private void openPicturePanel()
	{

		GLProfile imgProfile = GLProfile.get(GLProfile.GL2);
		GLCapabilities imgCapabilities = new GLCapabilities(imgProfile);
		GLCanvas imgGlCanvas=frame.getImgGlCanvas();
		imgGlCanvas=new GLCanvas(imgCapabilities);
        GLEventProcesserImg glEventProcesserImg=new GLEventProcesserImg(frame);
        imgGlCanvas.addGLEventListener(glEventProcesserImg);
        imgGlCanvas.setBounds(585, 0, 580, 580);
        frame.setImgGlCanvas(imgGlCanvas);
        
		frame.getCenterPanel().remove(frame.getColorRightPanel());
    	frame.getCenterPanel().add(frame.getImgGlCanvas());
		frame.getCenterPanel().setBounds(10, 85, 1190, 725);
		frame.setBounds(160, 50, 1190, 725);
		frame.getImgGlCanvas().display();
	}
	
	/**
	 * ��UI�����������޲���ɫʱ���յ�ԭͼƬ�Ļ���
	 */
	private void closePicturePanel()
	{
		frame.getCenterPanel().remove(frame.getImgGlCanvas());
		frame.getImgGlCanvas().destroy();
		frame.getCenterPanel().setBounds(10, 85, 930, 725);
		frame.getCenterPanel().add(frame.getColorRightPanel());
		frame.setBounds(160, 50, 930, 725);
	}
	/**
	 * ��ǰ����
	 */
	public static void redo()
	{
		StaticData.isAddLines=false;
		StaticData.isZoomIn=false;
		StaticData.isZoomOut=false;
		StaticData.isDraw=true;
		StaticData.isCleanAll=false;
		StaticData.isSelRColor=false;
		StaticData.isSelLColor=false;
		StaticData.isSample=false;
		StaticData.isCurveLineOnly=false;
		StaticData.isColorCurveLine=false;
        if(StaticData.redoStack.size()>0)
        {
        	if(StaticData.redoRepairStack.size()>0)
			{
				StaticData.undoRepairStack.push(StaticData.repairCurves);
				StaticData.repairCurves=StaticData.redoRepairStack.pop();
			}
        	StaticData.undoStack.push(StaticData.allCurves);
        	StaticData.allCurves=StaticData.redoStack.pop();
 			frame.getGLCanvas().display();
        }
	}
	/**
	 * �����
	 */
	public static void undo()
	{
		StaticData.isAddLines=false;
		StaticData.isZoomIn=false;
		StaticData.isZoomOut=false;
		StaticData.isCleanAll=false;
		StaticData.isDraw=true;
		StaticData.isSelRColor=false;
		StaticData.isSelLColor=false;
		StaticData.isSample=false;
		StaticData.isCurveLineOnly=false;
		StaticData.isColorCurveLine=false;
		if(StaticData.undoStack.size()>0)
		{
			if(StaticData.undoRepairStack.size()>0)
			{
				StaticData.redoRepairStack.push(StaticData.repairCurves);
				StaticData.repairCurves=StaticData.undoRepairStack.pop();
			}
			StaticData.redoStack.push(StaticData.allCurves);
			StaticData.allCurves=StaticData.undoStack.pop();
			frame.getGLCanvas().display();
		}
	}
	/**
	 * ɾ������
	 */
	public static void deleteCurves()
	{
		StaticData.isAddLines=false;
		StaticData.isZoomIn=false;
		StaticData.isZoomOut=false;
		StaticData.isHandPan=false;
		StaticData.isDraw=true;
		StaticData.isSelRColor=false;
		StaticData.isSelLColor=false;
		StaticData.isCleanAll=false;
		StaticData.isPictureSample=false;
		StaticData.isPictureRepair=false;
		MethodTool.pushState();
		int nullNum=0;
		for(int i=0;i<StaticData.allCurves.size();i++){
			if(StaticData.allCurves.get(i).isSelected()){
				  StaticData.allCurves.set(i, null);
				  nullNum++;
				}
			}
		for(int i=0;i<nullNum;i++)
            StaticData.allCurves.remove(null);
		frame.getGLCanvas().display();
	}
	/*
	 * ������ȡ���������ϵ�ƫ�Ƶ�
	 */
	public static Point[] getColorPoint(Point p1,Point p2)
	{
	   Point[] colorPoint=new Point[2];
	   double[] V=new double[2];
	   double[] N=new double[2];
	   	V[0]=p2.getX()-p1.getX();
		V[1]=p2.getY()-p1.getY();
	
		N=MethodTool.raygetNormal(V);
		double[] PM=MethodTool.getPMValue(V);
		double leftX=p1.getX()-N[0]*PM[0]+0.5;
		double leftY=p1.getY()-N[1]*PM[1]+0.5;
		double rightX=p1.getX()+N[0]*PM[0]+0.5;
		double rightY=p1.getY()+N[1]*PM[1]+0.5;
		if(leftX>580) leftX=Constants.drawWidth-1;
		if(leftY>580) leftY=Constants.drawWidth-1;
		if(rightX>580) rightX=Constants.drawWidth-1;
		if(rightY>580) rightY=Constants.drawWidth-1;
		if(leftX<0) leftX=0;
		if(leftY<0)	leftY=0;
		if(rightX<0)	rightX=0;
		if(rightY<0)	rightY=0;
		Point leftcolorpoint=new Point((int)leftX,(int)leftY);
		Point rightcolorpoint=new Point((int)rightX,(int)rightY);
		colorPoint[0]=leftcolorpoint;
		colorPoint[1]=rightcolorpoint;
		return colorPoint;
	}
}
